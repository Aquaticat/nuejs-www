<p class="line-count">1913 lines</p><div class="columns">
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/components/listbox/listbox.ts"><pre class="pre-1"><h3>listbox.ts</h3>import {
  Fragment,
  computed,
  defineComponent,
  h,
  inject,
  nextTick,
  onMounted,
  onUnmounted,
  provide,
  ref,
  toRaw,
  watch,
  watchEffect,

<span class="comment">  // Types</span>
  ComputedRef,
  InjectionKey,
  Ref,
  UnwrapNestedRefs,
  PropType,
} from 'vue'

import { Features, render, omit, compact } from '../../utils/render'
import { useId } from '../../hooks/use-id'
import { Keys } from '../../keyboard'
import { calculateActiveIndex, Focus } from '../../utils/calculate-active-index'
import { dom } from '../../utils/dom'
import { useOpenClosed, State, useOpenClosedProvider } from '../../internal/open-closed'
import { match } from '../../utils/match'
import { useResolveButtonType } from '../../hooks/use-resolve-button-type'
import { FocusableMode, isFocusableElement, sortByDomNode } from '../../utils/focus-management'
import { useOutsideClick } from '../../hooks/use-outside-click'
import { Hidden, Features as HiddenFeatures } from '../../internal/hidden'
import { objectToFormEntries } from '../../utils/form'
import { useControllable } from '../../hooks/use-controllable'
import { useTrackedPointer } from '../../hooks/use-tracked-pointer'

function defaultComparator&ltT&gt(a: T, z: T): boolean {
  return a === z
}

enum ListboxStates {
  Open,
  Closed,
}

enum ValueMode {
  Single,
  Multi,
}

enum ActivationTrigger {
  Pointer,
  Other,
}

function nextFrame(cb: () =&gt void) {
  requestAnimationFrame(() =&gt requestAnimationFrame(cb))
}

type ListboxOptionData = {
  textValue: string
  disabled: boolean
  value: unknown
  domRef: Ref&ltHTMLElement | null&gt
}

type StateDefinition = {
<span class="comment">  // State</span>
  listboxState: Ref&ltListboxStates&gt
  value: ComputedRef&ltunknown&gt
  orientation: Ref&lt'vertical' | 'horizontal'&gt

  mode: ComputedRef&ltValueMode&gt

  compare: (a: unknown, z: unknown) =&gt boolean

  labelRef: Ref&ltHTMLLabelElement | null&gt
  buttonRef: Ref&ltHTMLButtonElement | null&gt
  optionsRef: Ref&ltHTMLDivElement | null&gt

  disabled: Ref&ltboolean&gt
  options: Ref&lt{ id: string; dataRef: ComputedRef&ltListboxOptionData&gt }[]&gt
  searchQuery: Ref&ltstring&gt
  activeOptionIndex: Ref&ltnumber | null&gt
  activationTrigger: Ref&ltActivationTrigger&gt

<span class="comment">  // State mutators</span>
  closeListbox(): void
  openListbox(): void
  goToOption(focus: Focus, id?: string, trigger?: ActivationTrigger): void
  search(value: string): void
  clearSearch(): void
  registerOption(id: string, dataRef: ComputedRef&ltListboxOptionData&gt): void
  unregisterOption(id: string): void
  select(value: unknown): void
}

let ListboxContext = Symbol('ListboxContext') as InjectionKey&ltStateDefinition&gt

function useListboxContext(component: string) {
  let context = inject(ListboxContext, null)

  if (context === null) {
    let err = new Error(`&lt${component} /&gt is missing a parent &ltListbox /&gt component.`)
    if (Error.captureStackTrace) Error.captureStackTrace(err, useListboxContext)
    throw err
  }

  return context
}

<span class="comment">// ---</span>

export let Listbox = defineComponent({
  name: 'Listbox',
  emits: { 'update:modelValue': (_value: any) =&gt true },
  props: {
    as: { type: [Object, String], default: 'template' },
    disabled: { type: [Boolean], default: false },
    by: { type: [String, Function], default: () =&gt defaultComparator },
    horizontal: { type: [Boolean], default: false },
    modelValue: {
      type: [Object, String, Number, Boolean] as PropType&lt
        object | string | number | boolean | null
      &gt,
      default: undefined,
    },
    defaultValue: {
      type: [Object, String, Number, Boolean] as PropType&lt
        object | string | number | boolean | null
      &gt,
      default: undefined,
    },
    form: { type: String, optional: true },
    name: { type: String, optional: true },
    multiple: { type: [Boolean], default: false },
  },
  inheritAttrs: false,
  setup(props, { slots, attrs, emit }) {
    let listboxState = ref&ltStateDefinition['listboxState']['value']&gt(ListboxStates.Closed)
    let labelRef = ref&ltStateDefinition['labelRef']['value']&gt(null)
    let buttonRef = ref&ltStateDefinition['buttonRef']['value']&gt(null)
    let optionsRef = ref&ltStateDefinition['optionsRef']['value']&gt(null)
    let options = ref&ltStateDefinition['options']['value']&gt([])
    let searchQuery = ref&ltStateDefinition['searchQuery']['value']&gt('')
    let activeOptionIndex = ref&ltStateDefinition['activeOptionIndex']['value']&gt(null)
    let activationTrigger = ref&ltStateDefinition['activationTrigger']['value']&gt(
      ActivationTrigger.Other
    )

    function adjustOrderedState(
      adjustment: (
        options: UnwrapNestedRefs&ltStateDefinition['options']['value']&gt
      ) =&gt UnwrapNestedRefs&ltStateDefinition['options']['value']&gt = (i) =&gt i
    ) {
      let currentActiveOption =
        activeOptionIndex.value !== null ? options.value[activeOptionIndex.value] : null

      let sortedOptions = sortByDomNode(adjustment(options.value.slice()), (option) =&gt
        dom(option.dataRef.domRef)
      )

<span class="comment">      // If we inserted an option before the current active option then the active option index</span>
<span class="comment">      // would be wrong. To fix this, we will re-lookup the correct index.</span>
      let adjustedActiveOptionIndex = currentActiveOption
        ? sortedOptions.indexOf(currentActiveOption)
        : null

<span class="comment">      // Reset to `null` in case the currentActiveOption was removed.</span>
      if (adjustedActiveOptionIndex === -1) {
        adjustedActiveOptionIndex = null
      }

      return {
        options: sortedOptions,
        activeOptionIndex: adjustedActiveOptionIndex,
      }
    }

    let mode = computed(() =&gt (props.multiple ? ValueMode.Multi : ValueMode.Single))
    let [value, theirOnChange] = useControllable(
      computed(() =&gt
        props.modelValue === undefined
          ? match(mode.value, {
              [ValueMode.Multi]: [],
              [ValueMode.Single]: undefined,
            })
          : props.modelValue
      ),
      (value: unknown) =&gt emit('update:modelValue', value),
      computed(() =&gt props.defaultValue)
    )

    let api = {
      listboxState,
      value,
      mode,
      compare(a: any, z: any) {
        if (typeof props.by === 'string') {
          let property = props.by as unknown as any
          return a?.[property] === z?.[property]
        }
        return props.by(a, z)
      },
      orientation: computed(() =&gt (props.horizontal ? 'horizontal' : 'vertical')),
      labelRef,
      buttonRef,
      optionsRef,
      disabled: computed(() =&gt props.disabled),
      options,
      searchQuery,
      activeOptionIndex,
      activationTrigger,
      closeListbox() {
        if (props.disabled) return
        if (listboxState.value === ListboxStates.Closed) return
        listboxState.value = ListboxStates.Closed
        activeOptionIndex.value = null
      },
      openListbox() {
        if (props.disabled) return
        if (listboxState.value === ListboxStates.Open) return
        listboxState.value = ListboxStates.Open
      },
      goToOption(focus: Focus, id?: string, trigger?: ActivationTrigger) {
        if (props.disabled) return
        if (listboxState.value === ListboxStates.Closed) return

        let adjustedState = adjustOrderedState()
        let nextActiveOptionIndex = calculateActiveIndex(
          focus === Focus.Specific
            ? { focus: Focus.Specific, id: id! }
            : { focus: focus as Exclude&ltFocus, Focus.Specific&gt },
          {
            resolveItems: () =&gt adjustedState.options,
            resolveActiveIndex: () =&gt adjustedState.activeOptionIndex,
            resolveId: (option) =&gt option.id,
            resolveDisabled: (option) =&gt option.dataRef.disabled,
          }
        )

        searchQuery.value = ''
        activeOptionIndex.value = nextActiveOptionIndex
        activationTrigger.value = trigger ?? ActivationTrigger.Other
        options.value = adjustedState.options
      },
      search(value: string) {
        if (props.disabled) return
        if (listboxState.value === ListboxStates.Closed) return

        let wasAlreadySearching = searchQuery.value !== ''
        let offset = wasAlreadySearching ? 0 : 1

        searchQuery.value += value.toLowerCase()

        let reOrderedOptions =
          activeOptionIndex.value !== null
            ? options.value
                .slice(activeOptionIndex.value + offset)
                .concat(options.value.slice(0, activeOptionIndex.value + offset))
            : options.value

        let matchingOption = reOrderedOptions.find(
          (option) =&gt
            option.dataRef.textValue.startsWith(searchQuery.value) && !option.dataRef.disabled
        )

        let matchIdx = matchingOption ? options.value.indexOf(matchingOption) : -1
        if (matchIdx === -1 || matchIdx === activeOptionIndex.value) return

        activeOptionIndex.value = matchIdx
        activationTrigger.value = ActivationTrigger.Other
      },
      clearSearch() {
        if (props.disabled) return
        if (listboxState.value === ListboxStates.Closed) return
        if (searchQuery.value === '') return

        searchQuery.value = ''
      },
      registerOption(id: string, dataRef: ListboxOptionData) {
        let adjustedState = adjustOrderedState((options) =&gt {
          return [...options, { id, dataRef }]
        })

        options.value = adjustedState.options
        activeOptionIndex.value = adjustedState.activeOptionIndex
      },
      unregisterOption(id: string) {
        let adjustedState = adjustOrderedState((options) =&gt {
          let idx = options.findIndex((a) =&gt a.id === id)
          if (idx !== -1) options.splice(idx, 1)
          return options
        })

        options.value = adjustedState.options
        activeOptionIndex.value = adjustedState.activeOptionIndex
        activationTrigger.value = ActivationTrigger.Other
      },
      select(value: unknown) {
        if (props.disabled) return
        theirOnChange(
          match(mode.value, {
            [ValueMode.Single]: () =&gt value,
            [ValueMode.Multi]: () =&gt {
              let copy = toRaw(api.value.value as unknown[]).slice()
              let raw = toRaw(value)

              let idx = copy.findIndex((value) =&gt api.compare(raw, toRaw(value)))
              if (idx === -1) {
                copy.push(raw)
              } else {
                copy.splice(idx, 1)
              }

              return copy
            },
          })
        )
      },
    }

<span class="comment">    // Handle outside click</span>
    useOutsideClick(
      [buttonRef, optionsRef],
      (event, target) =&gt {
        api.closeListbox()

        if (!isFocusableElement(target, FocusableMode.Loose)) {
          event.preventDefault()
          dom(buttonRef)?.focus()
        }
      },
      computed(() =&gt listboxState.value === ListboxStates.Open)
    )

<span class="comment">    // @ts-expect-error Types of property 'dataRef' are incompatible.</span>
    provide(ListboxContext, api)
    useOpenClosedProvider(
      computed(() =&gt
        match(listboxState.value, {
          [ListboxStates.Open]: State.Open,
          [ListboxStates.Closed]: State.Closed,
        })
      )
    )

    let form = computed(() =&gt dom(buttonRef)?.closest('form'))
    onMounted(() =&gt {
      watch(
        [form],
        () =&gt {
          if (!form.value) return
          if (props.defaultValue === undefined) return

          function handle() {
            api.select(props.defaultValue)
          }

          form.value.addEventListener('reset', handle)

          return () =&gt {
            form.value?.removeEventListener('reset', handle)
          }
        },
        { immediate: true }
      )
    })

    return () =&gt {
      let { name, modelValue, disabled, form, ...theirProps } = props

      let slot = { open: listboxState.value === ListboxStates.Open, disabled, value: value.value }

      return h(Fragment, [
        ...(name != null && value.value != null
          ? objectToFormEntries({ [name]: value.value }).map(([name, value]) =&gt
              h(
                Hidden,
                compact({
                  features: HiddenFeatures.Hidden,
                  key: name,
                  as: 'input',
                  type: 'hidden',
                  hidden: true,
                  readOnly: true,
                  form,
                  name,
                  value,
                })
              )
            )
          : []),
        render({
          ourProps: {},
          theirProps: {
            ...attrs,
            ...omit(theirProps, [
              'defaultValue',
              'onUpdate:modelValue',
              'horizontal',
              'multiple',
              'by',
            ]),
          },
          slot,
          slots,
          attrs,
          name: 'Listbox',
        }),
      ])
    }
  },
})

<span class="comment">// ---</span>

export let ListboxLabel = defineComponent({
  name: 'ListboxLabel',
  props: {
    as: { type: [Object, String], default: 'label' },
    id: { type: String, default: () =&gt `headlessui-listbox-label-${useId()}` },
  },
  setup(props, { attrs, slots }) {
    let api = useListboxContext('ListboxLabel')

    function handleClick() {
      dom(api.buttonRef)?.focus({ preventScroll: true })
    }

    return () =&gt {
      let slot = {
        open: api.listboxState.value === ListboxStates.Open,
        disabled: api.disabled.value,
      }
      let { id, ...theirProps } = props
      let ourProps = { id, ref: api.labelRef, onClick: handleClick }

      return render({
        ourProps,
        theirProps,
        slot,
        attrs,
        slots,
        name: 'ListboxLabel',
      })
    }
  },
})

<span class="comment">// ---</span>

export let ListboxButton = defineComponent({
  name: 'ListboxButton',
  props: {
    as: { type: [Object, String], default: 'button' },
    id: { type: String, default: () =&gt `headlessui-listbox-button-${useId()}` },
  },
  setup(props, { attrs, slots, expose }) {
    let api = useListboxContext('ListboxButton')

    expose({ el: api.buttonRef, $el: api.buttonRef })

    function handleKeyDown(event: KeyboardEvent) {
      switch (event.key) {
<span class="comment">        // Ref: https://www.w3.org/WAI/ARIA/apg/patterns/menubutton/#keyboard-interaction-13</span>

        case Keys.Space:
        case Keys.Enter:
        case Keys.ArrowDown:
          event.preventDefault()
          api.openListbox()
          nextTick(() =&gt {
            dom(api.optionsRef)?.focus({ preventScroll: true })
            if (!api.value.value) api.goToOption(Focus.First)
          })
          break

        case Keys.ArrowUp:
          event.preventDefault()
          api.openListbox()
          nextTick(() =&gt {
            dom(api.optionsRef)?.focus({ preventScroll: true })
            if (!api.value.value) api.goToOption(Focus.Last)
          })
          break
      }
    }

    function handleKeyUp(event: KeyboardEvent) {
      switch (event.key) {
        case Keys.Space:
<span class="comment">          // Required for firefox, event.preventDefault() in handleKeyDown for</span>
<span class="comment">          // the Space key doesn't cancel the handleKeyUp, which in turn</span>
<span class="comment">          // triggers a *click*.</span>
          event.preventDefault()
          break
      }
    }

    function handleClick(event: MouseEvent) {
      if (api.disabled.value) return
      if (api.listboxState.value === ListboxStates.Open) {
        api.closeListbox()
        nextTick(() =&gt dom(api.buttonRef)?.focus({ preventScroll: true }))
      } else {
        event.preventDefault()
        api.openListbox()
        nextFrame(() =&gt dom(api.optionsRef)?.focus({ preventScroll: true }))
      }
    }

    let type = useResolveButtonType(
      computed(() =&gt ({ as: props.as, type: attrs.type })),
      api.buttonRef
    )

    return () =&gt {
      let slot = {
        open: api.listboxState.value === ListboxStates.Open,
        disabled: api.disabled.value,
        value: api.value.value,
      }

      let { id, ...theirProps } = props
      let ourProps = {
        ref: api.buttonRef,
        id,
        type: type.value,
        'aria-haspopup': 'listbox',
        'aria-controls': dom(api.optionsRef)?.id,
        'aria-expanded': api.disabled.value
          ? undefined
          : api.listboxState.value === ListboxStates.Open,
        'aria-labelledby': api.labelRef.value ? [dom(api.labelRef)?.id, id].join(' ') : undefined,
        disabled: api.disabled.value === true ? true : undefined,
        onKeydown: handleKeyDown,
        onKeyup: handleKeyUp,
        onClick: handleClick,
      }

      return render({
        ourProps,
        theirProps,
        slot,
        attrs,
        slots,
        name: 'ListboxButton',
      })
    }
  },
})

<span class="comment">// ---</span>

export let ListboxOptions = defineComponent({
  name: 'ListboxOptions',
  props: {
    as: { type: [Object, String], default: 'ul' },
    static: { type: Boolean, default: false },
    unmount: { type: Boolean, default: true },
    id: { type: String, default: () =&gt `headlessui-listbox-options-${useId()}` },
  },
  setup(props, { attrs, slots, expose }) {
    let api = useListboxContext('ListboxOptions')
    let searchDebounce = ref&ltReturnType&lttypeof setTimeout&gt | null&gt(null)

    expose({ el: api.optionsRef, $el: api.optionsRef })

    function handleKeyDown(event: KeyboardEvent) {
      if (searchDebounce.value) clearTimeout(searchDebounce.value)

      switch (event.key) {
<span class="comment">        // Ref: https://www.w3.org/WAI/ARIA/apg/patterns/menu/#keyboard-interaction-12</span>

<span class="comment">        // @ts-expect-error Fallthrough is expected here</span>
        case Keys.Space:
          if (api.searchQuery.value !== '') {
            event.preventDefault()
            event.stopPropagation()
            return api.search(event.key)
          }
<span class="comment">        // When in type ahead mode, fallthrough</span>
        case Keys.Enter:
          event.preventDefault()
          event.stopPropagation()
          if (api.activeOptionIndex.value !== null) {
            let activeOption = api.options.value[api.activeOptionIndex.value]
            api.select(activeOption.dataRef.value)
          }
          if (api.mode.value === ValueMode.Single) {
            api.closeListbox()
            nextTick(() =&gt dom(api.buttonRef)?.focus({ preventScroll: true }))
          }
          break

        case match(api.orientation.value, {
          vertical: Keys.ArrowDown,
          horizontal: Keys.ArrowRight,
        }):
          event.preventDefault()
          event.stopPropagation()
          return api.goToOption(Focus.Next)

        case match(api.orientation.value, { vertical: Keys.ArrowUp, horizontal: Keys.ArrowLeft }):
          event.preventDefault()
          event.stopPropagation()
          return api.goToOption(Focus.Previous)

        case Keys.Home:
        case Keys.PageUp:
          event.preventDefault()
          event.stopPropagation()
          return api.goToOption(Focus.First)

        case Keys.End:
        case Keys.PageDown:
          event.preventDefault()
          event.stopPropagation()
          return api.goToOption(Focus.Last)

        case Keys.Escape:
          event.preventDefault()
          event.stopPropagation()
          api.closeListbox()
          nextTick(() =&gt dom(api.buttonRef)?.focus({ preventScroll: true }))
          break

        case Keys.Tab:
          event.preventDefault()
          event.stopPropagation()
          break

        default:
          if (event.key.length === 1) {
            api.search(event.key)
            searchDebounce.value = setTimeout(() =&gt api.clearSearch(), 350)
          }
          break
      }
    }

    let usesOpenClosedState = useOpenClosed()
    let visible = computed(() =&gt {
      if (usesOpenClosedState !== null) {
        return (usesOpenClosedState.value & State.Open) === State.Open
      }

      return api.listboxState.value === ListboxStates.Open
    })

    return () =&gt {
      let slot = { open: api.listboxState.value === ListboxStates.Open }
      let { id, ...theirProps } = props
      let ourProps = {
        'aria-activedescendant':
          api.activeOptionIndex.value === null
            ? undefined
            : api.options.value[api.activeOptionIndex.value]?.id,
        'aria-multiselectable': api.mode.value === ValueMode.Multi ? true : undefined,
        'aria-labelledby': dom(api.labelRef)?.id ?? dom(api.buttonRef)?.id,
        'aria-orientation': api.orientation.value,
        id,
        onKeydown: handleKeyDown,
        role: 'listbox',
        tabIndex: 0,
        ref: api.optionsRef,
      }

      return render({
        ourProps,
        theirProps,
        slot,
        attrs,
        slots,
        features: Features.RenderStrategy | Features.Static,
        visible: visible.value,
        name: 'ListboxOptions',
      })
    }
  },
})

export let ListboxOption = defineComponent({
  name: 'ListboxOption',
  props: {
    as: { type: [Object, String], default: 'li' },
    value: {
      type: [Object, String, Number, Boolean] as PropType&lt
        object | string | number | boolean | null
      &gt,
    },
    disabled: { type: Boolean, default: false },
    id: { type: String, default: () =&gt `headlessui-listbox.option-${useId()}` },
  },
  setup(props, { slots, attrs, expose }) {
    let api = useListboxContext('ListboxOption')
    let internalOptionRef = ref&ltHTMLElement | null&gt(null)

    expose({ el: internalOptionRef, $el: internalOptionRef })

    let active = computed(() =&gt {
      return api.activeOptionIndex.value !== null
        ? api.options.value[api.activeOptionIndex.value].id === props.id
        : false
    })

    let selected = computed(() =&gt
      match(api.mode.value, {
        [ValueMode.Single]: () =&gt api.compare(toRaw(api.value.value), toRaw(props.value)),
        [ValueMode.Multi]: () =&gt
          (toRaw(api.value.value) as unknown[]).some((value) =&gt
            api.compare(toRaw(value), toRaw(props.value))
          ),
      })
    )
    let isFirstSelected = computed(() =&gt {
      return match(api.mode.value, {
        [ValueMode.Multi]: () =&gt {
          let currentValues = toRaw(api.value.value) as unknown[]

          return (
            api.options.value.find((option) =&gt
              currentValues.some((value) =&gt api.compare(toRaw(value), toRaw(option.dataRef.value)))
            )?.id === props.id
          )
        },
        [ValueMode.Single]: () =&gt selected.value,
      })
    })

    let dataRef = computed&ltListboxOptionData&gt(() =&gt ({
      disabled: props.disabled,
      value: props.value,
      textValue: '',
      domRef: internalOptionRef,
    }))
    onMounted(() =&gt {
      let textValue = dom(internalOptionRef)?.textContent?.toLowerCase().trim()
      if (textValue !== undefined) dataRef.value.textValue = textValue
    })

    onMounted(() =&gt api.registerOption(props.id, dataRef))
    onUnmounted(() =&gt api.unregisterOption(props.id))

    onMounted(() =&gt {
      watch(
        [api.listboxState, selected],
        () =&gt {
          if (api.listboxState.value !== ListboxStates.Open) return
          if (!selected.value) return

          match(api.mode.value, {
            [ValueMode.Multi]: () =&gt {
              if (isFirstSelected.value) api.goToOption(Focus.Specific, props.id)
            },
            [ValueMode.Single]: () =&gt {
              api.goToOption(Focus.Specific, props.id)
            },
          })
        },
        { immediate: true }
      )
    })

    watchEffect(() =&gt {
      if (api.listboxState.value !== ListboxStates.Open) return
      if (!active.value) return
      if (api.activationTrigger.value === ActivationTrigger.Pointer) return
      nextTick(() =&gt dom(internalOptionRef)?.scrollIntoView?.({ block: 'nearest' }))
    })

    function handleClick(event: MouseEvent) {
      if (props.disabled) return event.preventDefault()
      api.select(props.value)
      if (api.mode.value === ValueMode.Single) {
        api.closeListbox()
        nextTick(() =&gt dom(api.buttonRef)?.focus({ preventScroll: true }))
      }
    }

    function handleFocus() {
      if (props.disabled) return api.goToOption(Focus.Nothing)
      api.goToOption(Focus.Specific, props.id)
    }

    let pointer = useTrackedPointer()

    function handleEnter(evt: PointerEvent) {
      pointer.update(evt)
    }

    function handleMove(evt: PointerEvent) {
      if (!pointer.wasMoved(evt)) return
      if (props.disabled) return
      if (active.value) return
      api.goToOption(Focus.Specific, props.id, ActivationTrigger.Pointer)
    }

    function handleLeave(evt: PointerEvent) {
      if (!pointer.wasMoved(evt)) return
      if (props.disabled) return
      if (!active.value) return
      api.goToOption(Focus.Nothing)
    }

    return () =&gt {
      let { disabled } = props
      let slot = { active: active.value, selected: selected.value, disabled }
      let { id, value: _value, disabled: _disabled, ...theirProps } = props
      let ourProps = {
        id,
        ref: internalOptionRef,
        role: 'option',
        tabIndex: disabled === true ? undefined : -1,
        'aria-disabled': disabled === true ? true : undefined,
<span class="comment">        // According to the WAI-ARIA best practices, we should use aria-checked for</span>
<span class="comment">        // multi-select,but Voice-Over disagrees. So we use aria-checked instead for</span>
<span class="comment">        // both single and multi-select.</span>
        'aria-selected': selected.value,
        disabled: undefined, // Never forward the `disabled` prop
        onClick: handleClick,
        onFocus: handleFocus,
        onPointerenter: handleEnter,
        onMouseenter: handleEnter,
        onPointermove: handleMove,
        onMousemove: handleMove,
        onPointerleave: handleLeave,
        onMouseleave: handleLeave,
      }

      return render({
        ourProps,
        theirProps,
        slot,
        attrs,
        slots,
        name: 'ListboxOption',
      })
    }
  },
})
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/hooks/use-controllable.ts"><pre class="pre-2"><h3>use-controllable.ts</h3>import { computed, ComputedRef, UnwrapRef, ref } from 'vue'

export function useControllable&ltT&gt(
  controlledValue: ComputedRef&ltT | undefined&gt,
  onChange?: (value: T) =&gt void,
  defaultValue?: ComputedRef&ltT&gt
) {
  let internalValue = ref(defaultValue?.value)
  let isControlled = computed(() =&gt controlledValue.value !== undefined)

  return [
    computed(() =&gt (isControlled.value ? controlledValue.value : internalValue.value)),
    function (value: unknown) {
      if (isControlled.value) {
        return onChange?.(value as T)
      } else {
        internalValue.value = value as UnwrapRef&ltT&gt
        return onChange?.(value as T)
      }
    },
  ] as const
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/hooks/use-id.ts"><pre class="pre-3"><h3>use-id.ts</h3>let id = 0
function generateId() {
  return ++id
}

export function useId() {
  return generateId()
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/hooks/use-outside-click.ts"><pre class="pre-4"><h3>use-outside-click.ts</h3>import { computed, Ref, ComputedRef, ref } from 'vue'
import { FocusableMode, isFocusableElement } from '../utils/focus-management'
import { dom } from '../utils/dom'
import { useDocumentEvent } from './use-document-event'

type Container = Ref&ltHTMLElement | null&gt | HTMLElement | null
type ContainerCollection = Container[] | Set&ltContainer&gt
type ContainerInput = Container | ContainerCollection

export function useOutsideClick(
  containers: ContainerInput | (() =&gt ContainerInput),
  cb: (event: MouseEvent | PointerEvent | FocusEvent, target: HTMLElement) =&gt void,
  enabled: ComputedRef&ltboolean&gt = computed(() =&gt true)
) {
  function handleOutsideClick&ltE extends MouseEvent | PointerEvent | FocusEvent&gt(
    event: E,
    resolveTarget: (event: E) =&gt HTMLElement | null
  ) {
    if (!enabled.value) return

<span class="comment">    // Check whether the event got prevented already. This can happen if you use the</span>
<span class="comment">    // useOutsideClick hook in both a Dialog and a Menu and the inner Menu "cancels" the default</span>
<span class="comment">    // behaviour so that only the Menu closes and not the Dialog (yet)</span>
    if (event.defaultPrevented) return

    let target = resolveTarget(event)

    if (target === null) {
      return
    }

<span class="comment">    // Ignore if the target doesn't exist in the DOM anymore</span>
    if (!target.getRootNode().contains(target)) return

    let _containers = (function resolve(containers): ContainerCollection {
      if (typeof containers === 'function') {
        return resolve(containers())
      }

      if (Array.isArray(containers)) {
        return containers
      }

      if (containers instanceof Set) {
        return containers
      }

      return [containers]
    })(containers)

<span class="comment">    // Ignore if the target exists in one of the containers</span>
    for (let container of _containers) {
      if (container === null) continue
      let domNode = container instanceof HTMLElement ? container : dom(container)
      if (domNode?.contains(target)) {
        return
      }

<span class="comment">      // If the click crossed a shadow boundary, we need to check if the container</span>
<span class="comment">      // is inside the tree by using `composedPath` to "pierce" the shadow boundary</span>
      if (event.composed && event.composedPath().includes(domNode as EventTarget)) {
        return
      }
    }

<span class="comment">    // This allows us to check whether the event was defaultPrevented when you are nesting this</span>
<span class="comment">    // inside a `&ltDialog /&gt` for example.</span>
    if (
<span class="comment">      // This check alllows us to know whether or not we clicked on a "focusable" element like a</span>
<span class="comment">      // button or an input. This is a backwards compatibility check so that you can open a &ltMenu</span>
<span class="comment">      // /&gt and click on another &ltMenu /&gt which should close Menu A and open Menu B. We might</span>
<span class="comment">      // revisit that so that you will require 2 clicks instead.</span>
      !isFocusableElement(target, FocusableMode.Loose) &&
<span class="comment">      // This could be improved, but the `Combobox.Button` adds tabIndex={-1} to make it</span>
<span class="comment">      // unfocusable via the keyboard so that tabbing to the next item from the input doesn't</span>
<span class="comment">      // first go to the button.</span>
      target.tabIndex !== -1
    ) {
      event.preventDefault()
    }

    return cb(event, target)
  }

  let initialClickTarget = ref&ltEventTarget | null&gt(null)

  useDocumentEvent(
    'mousedown',
    (event) =&gt {
      if (enabled.value) {
        initialClickTarget.value = event.composedPath?.()?.[0] || event.target
      }
    },
    true
  )

  useDocumentEvent(
    'click',
    (event) =&gt {
      if (!initialClickTarget.value) {
        return
      }

      handleOutsideClick(event, () =&gt {
        return initialClickTarget.value as HTMLElement
      })

      initialClickTarget.value = null
    },

<span class="comment">    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`</span>
<span class="comment">    // don't "cancel" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`</span>
<span class="comment">    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,</span>
<span class="comment">    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.</span>
    true
  )

<span class="comment">  // When content inside an iframe is clicked `window` will receive a blur event</span>
<span class="comment">  // This can happen when an iframe _inside_ a window is clicked</span>
<span class="comment">  // Or, if headless UI is *in* the iframe, when a content in a window containing that iframe is clicked</span>

<span class="comment">  // In this case we care only about the first case so we check to see if the active element is the iframe</span>
<span class="comment">  // If so this was because of a click, focus, or other interaction with the child iframe</span>
<span class="comment">  // and we can consider it an "outside click"</span>
  useDocumentEvent(
    'blur',
    (event) =&gt
      handleOutsideClick(event, () =&gt
        window.document.activeElement instanceof HTMLIFrameElement
          ? window.document.activeElement
          : null
      ),
    true
  )
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/hooks/use-resolve-button-type.ts"><pre class="pre-5"><h3>use-resolve-button-type.ts</h3>import { ref, onMounted, watchEffect, Ref } from 'vue'
import { dom } from '../utils/dom'

function resolveType(type: unknown, as: string | object) {
  if (type) return type

  let tag = as ?? 'button'
  if (typeof tag === 'string' && tag.toLowerCase() === 'button') return 'button'

  return undefined
}

export function useResolveButtonType(
  data: Ref&lt{ as: string | object; type?: unknown }&gt,
  refElement: Ref&ltHTMLElement | null&gt
) {
  let type = ref(resolveType(data.value.type, data.value.as))

  onMounted(() =&gt {
    type.value = resolveType(data.value.type, data.value.as)
  })

  watchEffect(() =&gt {
    if (type.value) return
    if (!dom(refElement)) return

    if (dom(refElement) instanceof HTMLButtonElement && !dom(refElement)?.hasAttribute('type')) {
      type.value = 'button'
    }
  })

  return type
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/hooks/use-tracked-pointer.ts"><pre class="pre-6"><h3>use-tracked-pointer.ts</h3>import { ref } from 'vue'

type PointerPosition = [x: number, y: number]

function eventToPosition(evt: PointerEvent): PointerPosition {
  return [evt.screenX, evt.screenY]
}

export function useTrackedPointer() {
  let lastPos = ref&ltPointerPosition&gt([-1, -1])

  return {
    wasMoved(evt: PointerEvent) {
<span class="comment">      // FIXME: Remove this once we use browser testing in all the relevant places.</span>
<span class="comment">      // NOTE: This is replaced with a compile-time define during the build process</span>
<span class="comment">      // This hack exists to work around a few failing tests caused by our inability to "move" the virtual pointer in JSDOM pointer events.</span>
      if (typeof process !== 'undefined' && process.env.TEST_BYPASS_TRACKED_POINTER) {
        return true
      }

      let newPos = eventToPosition(evt)

      if (lastPos.value[0] === newPos[0] && lastPos.value[1] === newPos[1]) {
        return false
      }

      lastPos.value = newPos
      return true
    },

    update(evt: PointerEvent) {
      lastPos.value = eventToPosition(evt)
    },
  }
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/utils/calculate-active-index.ts"><pre class="pre-7"><h3>calculate-active-index.ts</h3>function assertNever(x: never): never {
  throw new Error('Unexpected object: ' + x)
}

export enum Focus {
  /** Focus the first non-disabled item. */
  First,

  /** Focus the previous non-disabled item. */
  Previous,

  /** Focus the next non-disabled item. */
  Next,

  /** Focus the last non-disabled item. */
  Last,

  /** Focus a specific item based on the `id` of the item. */
  Specific,

  /** Focus no items at all. */
  Nothing,
}

export function calculateActiveIndex&ltTItem&gt(
  action: { focus: Focus.Specific; id: string } | { focus: Exclude&ltFocus, Focus.Specific&gt },
  resolvers: {
    resolveItems(): TItem[]
    resolveActiveIndex(): number | null
    resolveId(item: TItem): string
    resolveDisabled(item: TItem): boolean
  }
) {
  let items = resolvers.resolveItems()
  if (items.length &lt= 0) return null

  let currentActiveIndex = resolvers.resolveActiveIndex()
  let activeIndex = currentActiveIndex ?? -1

  let nextActiveIndex = (() =&gt {
    switch (action.focus) {
      case Focus.First:
        return items.findIndex((item) =&gt !resolvers.resolveDisabled(item))

      case Focus.Previous: {
        let idx = items
          .slice()
          .reverse()
          .findIndex((item, idx, all) =&gt {
            if (activeIndex !== -1 && all.length - idx - 1 &gt= activeIndex) return false
            return !resolvers.resolveDisabled(item)
          })
        if (idx === -1) return idx
        return items.length - 1 - idx
      }

      case Focus.Next:
        return items.findIndex((item, idx) =&gt {
          if (idx &lt= activeIndex) return false
          return !resolvers.resolveDisabled(item)
        })

      case Focus.Last: {
        let idx = items
          .slice()
          .reverse()
          .findIndex((item) =&gt !resolvers.resolveDisabled(item))
        if (idx === -1) return idx
        return items.length - 1 - idx
      }

      case Focus.Specific:
        return items.findIndex((item) =&gt resolvers.resolveId(item) === action.id)

      case Focus.Nothing:
        return null

      default:
        assertNever(action)
    }
  })()

  return nextActiveIndex === -1 ? currentActiveIndex : nextActiveIndex
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/utils/dom.ts"><pre class="pre-8"><h3>dom.ts</h3>import { Ref, ComponentPublicInstance } from 'vue'

export function dom&ltT extends Element | ComponentPublicInstance&gt(ref?: Ref&ltT | null&gt): T | null {
  if (ref == null) return null
  if (ref.value == null) return null

  return (ref.value as { $el?: T }).$el ?? ref.value
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/utils/focus-management.ts"><pre class="pre-9"><h3>focus-management.ts</h3>import { nextTick } from 'vue'
import { match } from './match'
import { getOwnerDocument } from './owner'

<span class="comment">// Credit:</span>
<span class="comment">//  - https://stackoverflow.com/a/30753870</span>
let focusableSelector = [
  '[contentEditable=true]',
  '[tabindex]',
  'a[href]',
  'area[href]',
  'button:not([disabled])',
  'iframe',
  'input:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
]
  .map(
    process.env.NODE_ENV === 'test'
      ? // TODO: Remove this once JSDOM fixes the issue where an element that is
<span class="comment">        // "hidden" can be the document.activeElement, because this is not possible</span>
<span class="comment">        // in real browsers.</span>
        (selector) =&gt `${selector}:not([tabindex='-1']):not([style*='display: none'])`
      : (selector) =&gt `${selector}:not([tabindex='-1'])`
  )
  .join(',')

export enum Focus {
  /** Focus the first non-disabled element */
  First = 1 &lt&lt 0,

  /** Focus the previous non-disabled element */
  Previous = 1 &lt&lt 1,

  /** Focus the next non-disabled element */
  Next = 1 &lt&lt 2,

  /** Focus the last non-disabled element */
  Last = 1 &lt&lt 3,

  /** Wrap tab around */
  WrapAround = 1 &lt&lt 4,

  /** Prevent scrolling the focusable elements into view */
  NoScroll = 1 &lt&lt 5,
}

export enum FocusResult {
  Error,
  Overflow,
  Success,
  Underflow,
}

enum Direction {
  Previous = -1,
  Next = 1,
}

export function getFocusableElements(container: HTMLElement | null = document.body) {
  if (container == null) return []
  return Array.from(container.querySelectorAll&ltHTMLElement&gt(focusableSelector)).sort(
<span class="comment">    // We want to move `:tabindex="0"` to the end of the list, this is what the browser does as well.</span>
    (a, z) =&gt
      Math.sign((a.tabIndex || Number.MAX_SAFE_INTEGER) - (z.tabIndex || Number.MAX_SAFE_INTEGER))
  )
}

export enum FocusableMode {
  /** The element itself must be focusable. */
  Strict,

  /** The element should be inside of a focusable element. */
  Loose,
}

export function isFocusableElement(
  element: HTMLElement,
  mode: FocusableMode = FocusableMode.Strict
) {
  if (element === getOwnerDocument(element)?.body) return false

  return match(mode, {
    [FocusableMode.Strict]() {
      return element.matches(focusableSelector)
    },
    [FocusableMode.Loose]() {
      let next: HTMLElement | null = element

      while (next !== null) {
        if (next.matches(focusableSelector)) return true
        next = next.parentElement
      }

      return false
    },
  })
}

export function restoreFocusIfNecessary(element: HTMLElement | null) {
  let ownerDocument = getOwnerDocument(element)
  nextTick(() =&gt {
    if (
      ownerDocument &&
      !isFocusableElement(ownerDocument.activeElement as HTMLElement, FocusableMode.Strict)
    ) {
      focusElement(element)
    }
  })
}

<span class="comment">// The method of triggering an action, this is used to determine how we should</span>
<span class="comment">// restore focus after an action has been performed.</span>
enum ActivationMethod {
  /* If the action was triggered by a keyboard event. */
  Keyboard = 0,

  /* If the action was triggered by a mouse / pointer / ... event.*/
  Mouse = 1,
}

<span class="comment">// We want to be able to set and remove the `data-headlessui-mouse` attribute on the `html` element.</span>
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  document.addEventListener(
    'keydown',
    (event) =&gt {
      if (event.metaKey || event.altKey || event.ctrlKey) {
        return
      }

      document.documentElement.dataset.headlessuiFocusVisible = ''
    },
    true
  )

  document.addEventListener(
    'click',
    (event) =&gt {
<span class="comment">      // Event originated from an actual mouse click</span>
      if (event.detail === ActivationMethod.Mouse) {
        delete document.documentElement.dataset.headlessuiFocusVisible
      }

<span class="comment">      // Event originated from a keyboard event that triggered the `click` event</span>
      else if (event.detail === ActivationMethod.Keyboard) {
        document.documentElement.dataset.headlessuiFocusVisible = ''
      }
    },
    true
  )
}

export function focusElement(element: HTMLElement | null) {
  element?.focus({ preventScroll: true })
}

<span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select</span>
let selectableSelector = ['textarea', 'input'].join(',')
function isSelectableElement(
  element: Element | null
): element is HTMLInputElement | HTMLTextAreaElement {
  return element?.matches?.(selectableSelector) ?? false
}

export function sortByDomNode&ltT&gt(
  nodes: T[],
  resolveKey: (item: T) =&gt HTMLElement | null = (i) =&gt i as unknown as HTMLElement | null
): T[] {
  return nodes.slice().sort((aItem, zItem) =&gt {
    let a = resolveKey(aItem)
    let z = resolveKey(zItem)

    if (a === null || z === null) return 0

    let position = a.compareDocumentPosition(z)

    if (position & Node.DOCUMENT_POSITION_FOLLOWING) return -1
    if (position & Node.DOCUMENT_POSITION_PRECEDING) return 1
    return 0
  })
}

export function focusFrom(current: HTMLElement | null, focus: Focus) {
  return focusIn(getFocusableElements(), focus, { relativeTo: current })
}

export function focusIn(
  container: HTMLElement | HTMLElement[],
  focus: Focus,
  {
    sorted = true,
    relativeTo = null,
    skipElements = [],
  }: Partial&lt{ sorted: boolean; relativeTo: HTMLElement | null; skipElements: HTMLElement[] }&gt = {}
) {
  let ownerDocument =
    (Array.isArray(container)
      ? container.length &gt 0
        ? container[0].ownerDocument
        : document
      : container?.ownerDocument) ?? document

  let elements = Array.isArray(container)
    ? sorted
      ? sortByDomNode(container)
      : container
    : getFocusableElements(container)

  if (skipElements.length &gt 0 && elements.length &gt 1) {
    elements = elements.filter((x) =&gt !skipElements.includes(x))
  }

  relativeTo = relativeTo ?? (ownerDocument.activeElement as HTMLElement)

  let direction = (() =&gt {
    if (focus & (Focus.First | Focus.Next)) return Direction.Next
    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous

    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')
  })()

  let startIndex = (() =&gt {
    if (focus & Focus.First) return 0
    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(relativeTo)) - 1
    if (focus & Focus.Next) return Math.max(0, elements.indexOf(relativeTo)) + 1
    if (focus & Focus.Last) return elements.length - 1

    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')
  })()

  let focusOptions = focus & Focus.NoScroll ? { preventScroll: true } : {}

  let offset = 0
  let total = elements.length
  let next = undefined
  do {
<span class="comment">    // Guard against infinite loops</span>
    if (offset &gt= total || offset + total &lt= 0) return FocusResult.Error

    let nextIdx = startIndex + offset

    if (focus & Focus.WrapAround) {
      nextIdx = (nextIdx + total) % total
    } else {
      if (nextIdx &lt 0) return FocusResult.Underflow
      if (nextIdx &gt= total) return FocusResult.Overflow
    }

    next = elements[nextIdx]

<span class="comment">    // Try the focus the next element, might not work if it is "hidden" to the user.</span>
    next?.focus(focusOptions)

<span class="comment">    // Try the next one in line</span>
    offset += direction
  } while (next !== ownerDocument.activeElement)

<span class="comment">  // By default if you &ltTab&gt to a text input or a textarea, the browser will</span>
<span class="comment">  // select all the text once the focus is inside these DOM Nodes. However,</span>
<span class="comment">  // since we are manually moving focus this behaviour is not happening. This</span>
<span class="comment">  // code will make sure that the text gets selected as-if you did it manually.</span>
<span class="comment">  // Note: We only do this when going forward / backward. Not for the</span>
<span class="comment">  // Focus.First or Focus.Last actions. This is similar to the `autoFocus`</span>
<span class="comment">  // behaviour on an input where the input will get focus but won't be</span>
<span class="comment">  // selected.</span>
  if (focus & (Focus.Next | Focus.Previous) && isSelectableElement(next)) {
    next.select()
  }

  return FocusResult.Success
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/utils/form.ts"><pre class="pre-10"><h3>form.ts</h3>type Entries = [string, string][]

export function objectToFormEntries(
  source: Record&ltstring, any&gt = {},
  parentKey: string | null = null,
  entries: Entries = []
): Entries {
  for (let [key, value] of Object.entries(source)) {
    append(entries, composeKey(parentKey, key), value)
  }

  return entries
}

function composeKey(parent: string | null, key: string): string {
  return parent ? parent + '[' + key + ']' : key
}

function append(entries: Entries, key: string, value: any): void {
  if (Array.isArray(value)) {
    for (let [subkey, subvalue] of value.entries()) {
      append(entries, composeKey(key, subkey.toString()), subvalue)
    }
  } else if (value instanceof Date) {
    entries.push([key, value.toISOString()])
  } else if (typeof value === 'boolean') {
    entries.push([key, value ? '1' : '0'])
  } else if (typeof value === 'string') {
    entries.push([key, value])
  } else if (typeof value === 'number') {
    entries.push([key, `${value}`])
  } else if (value === null || value === undefined) {
    entries.push([key, ''])
  } else {
    objectToFormEntries(value, key, entries)
  }
}

export function attemptSubmit(element: HTMLElement) {
  let form = (element as any)?.form ?? element.closest('form')
  if (!form) return

  for (let element of form.elements) {
    if (
      (element.tagName === 'INPUT' && element.type === 'submit') ||
      (element.tagName === 'BUTTON' && element.type === 'submit') ||
      (element.nodeName === 'INPUT' && element.type === 'image')
    ) {
<span class="comment">      // If you press `enter` in a normal input[type='text'] field, then the form will submit by</span>
<span class="comment">      // searching for the a submit element and "click" it. We could also use the</span>
<span class="comment">      // `form.requestSubmit()` function, but this has a downside where an `event.preventDefault()`</span>
<span class="comment">      // inside a `click` listener on the submit button won't stop the form from submitting.</span>
      element.click()
      return
    }
  }
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/utils/match.ts"><pre class="pre-11"><h3>match.ts</h3>export function match&ltTValue extends string | number = string, TReturnValue = unknown&gt(
  value: TValue,
  lookup: Record&ltTValue, TReturnValue | ((...args: any[]) =&gt TReturnValue)&gt,
  ...args: any[]
): TReturnValue {
  if (value in lookup) {
    let returnValue = lookup[value]
    return typeof returnValue === 'function' ? returnValue(...args) : returnValue
  }

  let error = new Error(
    `Tried to handle "${value}" but there is no handler defined. Only defined handlers are: ${Object.keys(
      lookup
    )
      .map((key) =&gt `"${key}"`)
      .join(', ')}.`
  )
  if (Error.captureStackTrace) Error.captureStackTrace(error, match)
  throw error
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/utils/render.ts"><pre class="pre-12"><h3>render.ts</h3>import { h, cloneVNode, Slots, Fragment, VNode } from 'vue'
import { match } from './match'

export enum Features {
  /** No features at all */
  None = 0,

  /**
   * When used, this will allow us to use one of the render strategies.
   *
   * **The render strategies are:**
   *    - **Unmount**   _(Will unmount the component.)_
   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_
   */
  RenderStrategy = 1,

  /**
   * When used, this will allow the user of our component to be in control. This can be used when
   * you want to transition based on some state.
   */
  Static = 2,
}

export enum RenderStrategy {
  Unmount,
  Hidden,
}

export function render({
  visible = true,
  features = Features.None,
  ourProps,
  theirProps,
  ...main
}: {
  ourProps: Record&ltstring, any&gt
  theirProps: Record&ltstring, any&gt
  slot: Record&ltstring, any&gt
  attrs: Record&ltstring, any&gt
  slots: Slots
  name: string
} & {
  features?: Features
  visible?: boolean
}) {
  let props = mergeProps(theirProps, ourProps)
  let mainWithProps = Object.assign(main, { props })

<span class="comment">  // Visible always render</span>
  if (visible) return _render(mainWithProps)

  if (features & Features.Static) {
<span class="comment">    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else</span>
    if (props.static) return _render(mainWithProps)
  }

  if (features & Features.RenderStrategy) {
    let strategy = props.unmount ?? true ? RenderStrategy.Unmount : RenderStrategy.Hidden

    return match(strategy, {
      [RenderStrategy.Unmount]() {
        return null
      },
      [RenderStrategy.Hidden]() {
        return _render({
          ...main,
          props: { ...props, hidden: true, style: { display: 'none' } },
        })
      },
    })
  }

<span class="comment">  // No features enabled, just render</span>
  return _render(mainWithProps)
}

function _render({
  props,
  attrs,
  slots,
  slot,
  name,
}: {
  props: Record&ltstring, any&gt
  slot: Record&ltstring, any&gt
  attrs: Record&ltstring, any&gt
  slots: Slots
  name: string
}) {
  let { as, ...incomingProps } = omit(props, ['unmount', 'static'])

  let children = slots.default?.(slot)

  let dataAttributes: Record&ltstring, string&gt = {}
  if (slot) {
    let exposeState = false
    let states = []
    for (let [k, v] of Object.entries(slot)) {
      if (typeof v === 'boolean') {
        exposeState = true
      }
      if (v === true) {
        states.push(k)
      }
    }

    if (exposeState) dataAttributes[`data-headlessui-state`] = states.join(' ')
  }

  if (as === 'template') {
    children = flattenFragments(children ?? [])

    if (Object.keys(incomingProps).length &gt 0 || Object.keys(attrs).length &gt 0) {
      let [firstChild, ...other] = children ?? []

      if (!isValidElement(firstChild) || other.length &gt 0) {
        throw new Error(
          [
            'Passing props on "template"!',
            '',
            `The current component &lt${name} /&gt is rendering a "template".`,
            `However we need to passthrough the following props:`,
            Object.keys(incomingProps)
              .concat(Object.keys(attrs))
              .map((name) =&gt name.trim())
              .filter((current, idx, all) =&gt all.indexOf(current) === idx)
              .sort((a, z) =&gt a.localeCompare(z))
              .map((line) =&gt `  - ${line}`)
              .join('\n'),
            '',
            'You can apply a few solutions:',
            [
              'Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".',
              'Render a single element as the child so that we can forward the props onto that element.',
            ]
              .map((line) =&gt `  - ${line}`)
              .join('\n'),
          ].join('\n')
        )
      }

      let mergedProps = mergeProps(firstChild.props ?? {}, incomingProps)
      let cloned = cloneVNode(firstChild, mergedProps)
<span class="comment">      // Explicitly override props starting with `on`. This is for event handlers, but there are</span>
<span class="comment">      // scenario's where we set them to `undefined` explicitly (when `aria-disabled="true"` is</span>
<span class="comment">      // happening instead of `disabled`). But cloneVNode doesn't like overriding `onXXX` props so</span>
<span class="comment">      // we have to do it manually.</span>
      for (let prop in mergedProps) {
        if (prop.startsWith('on')) {
          cloned.props ||= {}
          cloned.props[prop] = mergedProps[prop]
        }
      }
      return cloned
    }

    if (Array.isArray(children) && children.length === 1) {
      return children[0]
    }

    return children
  }

  return h(as, Object.assign({}, incomingProps, dataAttributes), {
    default: () =&gt children,
  })
}

/**
 * When passed a structure like this:
 * &ltExample&gt&ltspan&gtsomething&lt/span&gt&lt/Example&gt
 *
 * And Example is defined as:
 * &ltSomeComponent&gt&ltslot /&gt&lt/SomeComponent&gt
 *
 * We need to turn the fragment that &ltslot&gt represents into the slot.
 * Luckily by this point it's already rendered into an array of VNodes
 * for us so we can just flatten it directly.
 *
 * We have to do this recursively because there could be multiple
 * levels of Component nesting all with &ltslot&gt elements interspersed
 *
 * @param children
 * @returns
 */
function flattenFragments(children: VNode[]): VNode[] {
  return children.flatMap((child) =&gt {
    if (child.type === Fragment) {
      return flattenFragments(child.children as VNode[])
    }

    return [child]
  })
}

function mergeProps(...listOfProps: Record&ltany, any&gt[]) {
  if (listOfProps.length === 0) return {}
  if (listOfProps.length === 1) return listOfProps[0]

  let target: Record&ltany, any&gt = {}

  let eventHandlers: Record&lt
    string,
    ((event: { defaultPrevented: boolean }, ...args: any[]) =&gt void | undefined)[]
  &gt = {}

  for (let props of listOfProps) {
    for (let prop in props) {
<span class="comment">      // Collect event handlers</span>
      if (prop.startsWith('on') && typeof props[prop] === 'function') {
        eventHandlers[prop] ??= []
        eventHandlers[prop].push(props[prop])
      } else {
<span class="comment">        // Override incoming prop</span>
        target[prop] = props[prop]
      }
    }
  }

<span class="comment">  // Do not attach any event handlers when there is a `disabled` or `aria-disabled` prop set.</span>
  if (target.disabled || target['aria-disabled']) {
    return Object.assign(
      target,
<span class="comment">      // Set all event listeners that we collected to `undefined`. This is</span>
<span class="comment">      // important because of the `cloneElement` from above, which merges the</span>
<span class="comment">      // existing and new props, they don't just override therefore we have to</span>
<span class="comment">      // explicitly nullify them.</span>
      Object.fromEntries(Object.keys(eventHandlers).map((eventName) =&gt [eventName, undefined]))
    )
  }

<span class="comment">  // Merge event handlers</span>
  for (let eventName in eventHandlers) {
    Object.assign(target, {
      [eventName](event: { defaultPrevented: boolean }, ...args: any[]) {
        let handlers = eventHandlers[eventName]

        for (let handler of handlers) {
          if (event instanceof Event && event.defaultPrevented) {
            return
          }

          handler(event, ...args)
        }
      },
    })
  }

  return target
}

export function compact&ltT extends Record&ltany, any&gt&gt(object: T) {
  let clone = Object.assign({}, object)
  for (let key in clone) {
    if (clone[key] === undefined) delete clone[key]
  }
  return clone
}

export function omit&ltT extends Record&ltany, any&gt, Keys extends keyof T&gt(
  object: T,
  keysToOmit: readonly Keys[] = []
) {
  let clone = Object.assign({}, object) as T
  for (let key of keysToOmit) {
    if (key in clone) delete clone[key]
  }
  return clone as Omit&ltT, Keys&gt
}

function isValidElement(input: any): boolean {
  if (input == null) return false // No children
  if (typeof input.type === 'string') return true // 'div', 'span', ...
  if (typeof input.type === 'object') return true // Other components
  if (typeof input.type === 'function') return true // Built-ins like Transition
  return false // Comments, strings, ...
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/internal/hidden.ts"><pre class="pre-13"><h3>hidden.ts</h3>import { defineComponent, PropType } from 'vue'
import { render } from '../utils/render'

export enum Features {
<span class="comment">  // The default, no features.</span>
  None = 1 &lt&lt 0,

<span class="comment">  // Whether the element should be focusable or not.</span>
  Focusable = 1 &lt&lt 1,

<span class="comment">  // Whether it should be completely hidden, even to assistive technologies.</span>
  Hidden = 1 &lt&lt 2,
}

export let Hidden = defineComponent({
  name: 'Hidden',
  props: {
    as: { type: [Object, String], default: 'div' },
    features: { type: Number as PropType&ltFeatures&gt, default: Features.None },
  },
  setup(props, { slots, attrs }) {
    return () =&gt {
      let { features, ...theirProps } = props
      let ourProps = {
        'aria-hidden': (features & Features.Focusable) === Features.Focusable ? true : undefined,
        style: {
          position: 'fixed',
          top: 1,
          left: 1,
          width: 1,
          height: 0,
          padding: 0,
          margin: -1,
          overflow: 'hidden',
          clip: 'rect(0, 0, 0, 0)',
          whiteSpace: 'nowrap',
          borderWidth: '0',
          ...((features & Features.Hidden) === Features.Hidden &&
            !((features & Features.Focusable) === Features.Focusable) && { display: 'none' }),
        },
      }

      return render({
        ourProps,
        theirProps,
        slot: {},
        attrs,
        slots,
        name: 'Hidden',
      })
    }
  },
})
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/internal/open-closed.ts"><pre class="pre-14"><h3>open-closed.ts</h3>import {
  inject,
  provide,

<span class="comment">  // Types</span>
  InjectionKey,
  Ref,
} from 'vue'

let Context = Symbol('Context') as InjectionKey&ltRef&ltState&gt&gt

export enum State {
  Open = 1 &lt&lt 0,
  Closed = 1 &lt&lt 1,
  Closing = 1 &lt&lt 2,
  Opening = 1 &lt&lt 3,
}

export function hasOpenClosed() {
  return useOpenClosed() !== null
}

export function useOpenClosed() {
  return inject(Context, null)
}

export function useOpenClosedProvider(value: Ref&ltState&gt) {
  provide(Context, value)
}
</pre></a>
<a href="https://github.com/tailwindlabs/headlessui/tree/%40headlessui/vue%40v1.7.12/packages/%40headlessui-vue/src/keyboard.ts"><pre class="pre-15"><h3>keyboard.ts</h3><span class="comment">// TODO: This must already exist somewhere, right? 🤔</span>
<span class="comment">// Ref: https://www.w3.org/TR/uievents-key/#named-key-attribute-values</span>
export enum Keys {
  Space = ' ',
  Enter = 'Enter',
  Escape = 'Escape',
  Backspace = 'Backspace',
  Delete = 'Delete',

  ArrowLeft = 'ArrowLeft',
  ArrowUp = 'ArrowUp',
  ArrowRight = 'ArrowRight',
  ArrowDown = 'ArrowDown',

  Home = 'Home',
  End = 'End',

  PageUp = 'PageUp',
  PageDown = 'PageDown',

  Tab = 'Tab',
}
</pre></a>
</div>